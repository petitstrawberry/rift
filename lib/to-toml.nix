{ lib }:

# Simple TOML generator for rift configuration
# Converts Nix attribute sets to TOML format
rec {
  # Escape string for TOML
  escapeString = s:
    builtins.replaceStrings
      [ "\\" "\"" "\n" "\t" "\r" ]
      [ "\\\\" "\\\"" "\\n" "\\t" "\\r" ]
      s;

  # Convert a value to TOML representation
  toTOMLValue = value:
    if builtins.isBool value then
      (if value then "true" else "false")
    else if builtins.isInt value || builtins.isFloat value then
      builtins.toString value
    else if builtins.isString value then
      "\"${escapeString value}\""
    else if builtins.isList value then
      let
        items = map toTOMLValue value;
      in "[${builtins.concatStringsSep ", " items}]"
    else if builtins.isAttrs value then
      let
        items = lib.mapAttrsToList (k: v: "${k} = ${toTOMLValue v}") value;
      in "{ ${builtins.concatStringsSep ", " items} }"
    else
      throw "Unsupported TOML value type: ${builtins.typeOf value}";

  # Generate TOML section header
  sectionHeader = path:
    if builtins.length path == 0 then ""
    else "[${builtins.concatStringsSep "." path}]";

  # Check if a value is a "simple" value (not an attrs or list of attrs)
  isSimple = v:
    if builtins.isAttrs v then false
    else if builtins.isList v && builtins.length v > 0 then
      !(builtins.isAttrs (builtins.elemAt v 0))
    else true;

  # Generate key-value pairs for simple values
  keyValuePairs = indent: attrs:
    let
      simpleItems = lib.filterAttrs (k: v: isSimple v) attrs;
      lines = lib.mapAttrsToList (k: v: "${indent}${k} = ${toTOMLValue v}") simpleItems;
    in builtins.concatStringsSep "\n" lines;

  # Generate TOML for nested sections
  nestedSections = path: indent: attrs:
    let
      complexItems = lib.filterAttrs (k: v: !isSimple v) attrs;
      processItem = k: v:
        if builtins.isAttrs v then
          toTOMLSection (path ++ [k]) v
        else if builtins.isList v && builtins.length v > 0 && builtins.isAttrs (builtins.elemAt v 0) then
          # Array of tables
          let
            tableLines = map (item:
              let
                header = "[[${builtins.concatStringsSep "." (path ++ [k])}]]";
                pairs = keyValuePairs "" item;
                nested = nestedSections (path ++ [k]) "" item;
              in if pairs != "" then "${header}\n${pairs}${if nested != "" then "\n" + nested else ""}"
                 else if nested != "" then "${header}\n${nested}"
                 else header
            ) v;
          in builtins.concatStringsSep "\n\n" tableLines
        else "";
    in builtins.concatStringsSep "\n" (lib.mapAttrsToList processItem complexItems);

  # Generate a TOML section with its nested sections
  toTOMLSection = path: attrs:
    let
      header = sectionHeader path;
      indent = "  "; # 2-space indentation
      pairs = keyValuePairs indent attrs;
      nested = nestedSections path indent attrs;

      result = if header == "" then
        (if pairs != "" then pairs else "")
        + (if nested != "" then (if pairs != "" then "\n" else "") + nested else "")
      else
        header + (if pairs != "" then "\n" + pairs else "")
        + (if nested != "" then "\n\n" + nested else "");
    in result;

  # Main conversion function
  toTOML = attrs:
    let
      header = "# Generated by Nix-rift\n";
      rootPairs = keyValuePairs "" attrs;
      rootSections = nestedSections [] "" attrs;
      content = if rootPairs != "" then rootPairs + (if rootSections != "" then "\n\n" + rootSections else "")
                else rootSections;
    in header + "\n" + content + "\n";
}
